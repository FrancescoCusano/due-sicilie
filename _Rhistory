a3,
#caption=c('Tavola 1.10 BAM - CARB0100'),
#label=c('tab:a10.a'),
align = "llS[table-format=-2]S[table-format=-2]", # inserire un valore in piu' rispetto al numero delle colonne (questo perche' xtable conta anche il rownames)
digits=c(0,1,1,1) # inserire un valore in piu' rispetto al numero delle colonne (questo perche' xtable conta anche il rownames)
)
carb0100 <- xtable(
a3,
#caption=c('Tavola 1.10 BAM - CARB0100'),
#label=c('tab:a10.a'),
align = "llXX", # inserire un valore in piu' rispetto al numero delle colonne (questo perche' xtable conta anche il rownames)
digits=c(0,1,1,1) # inserire un valore in piu' rispetto al numero delle colonne (questo perche' xtable conta anche il rownames)
)
carb0100 <- xtable(
a3,
#caption=c('Tavola 1.10 BAM - CARB0100'),
#label=c('tab:a10.a'),
align = "llSS", # inserire un valore in piu' rispetto al numero delle colonne (questo perche' xtable conta anche il rownames)
digits=c(0,1,1,1) # inserire un valore in piu' rispetto al numero delle colonne (questo perche' xtable conta anche il rownames)
)
carb0100 <- xtable(
a10,
#caption=c('Tavola 1.10 BAM - CARB0100'),
#label=c('tab:a10.a'),
align = "ll*{9}{S}", # inserire un valore in piu' rispetto al numero delle colonne (questo perche' xtable conta anche il rownames)
digits=c(0,1,1,1,1,1,1,1,1,1,1) # inserire un valore in piu' rispetto al numero delle colonne (questo perche' xtable conta anche il rownames)
)
carb0100 <- xtable(
a3,
#caption=c('Tavola 1.10 BAM - CARB0100'),
#label=c('tab:a10.a'),
align = "ll*{2}{X}", # inserire un valore in piu' rispetto al numero delle colonne (questo perche' xtable conta anche il rownames)
digits=c(0,1,1,1) # inserire un valore in piu' rispetto al numero delle colonne (questo perche' xtable conta anche il rownames)
)
carb0100 <- xtable(
a3,
#caption=c('Tavola 1.10 BAM - CARB0100'),
#label=c('tab:a10.a'),
align = "ll\*{2}{X}", # inserire un valore in piu' rispetto al numero delle colonne (questo perche' xtable conta anche il rownames)
digits=c(0,1,1,1) # inserire un valore in piu' rispetto al numero delle colonne (questo perche' xtable conta anche il rownames)
)
carb0100 <- xtable(
a3,
#caption=c('Tavola 1.10 BAM - CARB0100'),
#label=c('tab:a10.a'),
align = "ll*\{2\}\{X\}", # inserire un valore in piu' rispetto al numero delle colonne (questo perche' xtable conta anche il rownames)
digits=c(0,1,1,1) # inserire un valore in piu' rispetto al numero delle colonne (questo perche' xtable conta anche il rownames)
)
carb0100 <- xtable(
a3,
#caption=c('Tavola 1.10 BAM - CARB0100'),
#label=c('tab:a10.a'),
align = "ll\*\{2\}\{X\}", # inserire un valore in piu' rispetto al numero delle colonne (questo perche' xtable conta anche il rownames)
digits=c(0,1,1,1) # inserire un valore in piu' rispetto al numero delle colonne (questo perche' xtable conta anche il rownames)
)
carb0100 <- xtable(
a3,
#caption=c('Tavola 1.10 BAM - CARB0100'),
#label=c('tab:a10.a'),
align = "llS[table-format=-2]S[table-format=-2]", # inserire un valore in piu' rispetto al numero delle colonne (questo perche' xtable conta anche il rownames)
digits=c(0,1,1,1) # inserire un valore in piu' rispetto al numero delle colonne (questo perche' xtable conta anche il rownames)
)
carb0100 <- xtable(
a3,
#caption=c('Tavola 1.10 BAM - CARB0100'),
#label=c('tab:a10.a'),
align = "llSS", # inserire un valore in piu' rispetto al numero delle colonne (questo perche' xtable conta anche il rownames)
digits=c(0,1,1,1) # inserire un valore in piu' rispetto al numero delle colonne (questo perche' xtable conta anche il rownames)
)
carb0100 <- xtable(
a3,
#caption=c('Tavola 1.10 BAM - CARB0100'),
#label=c('tab:a10.a'),
align = c("l", "l", "S[table-format=-2]", "S[table-format=-2]"), # inserire un valore in piu' rispetto al numero delle colonne (questo perche' xtable conta anche il rownames)
digits=c(0,1,1,1) # inserire un valore in piu' rispetto al numero delle colonne (questo perche' xtable conta anche il rownames)
)
carb0100 <- xtable(
a3,
#caption=c('Tavola 1.10 BAM - CARB0100'),
#label=c('tab:a10.a'),
align = c("l", "l", rep("S[table-format=-2]", 2)), # inserire un valore in piu' rispetto al numero delle colonne (questo perche' xtable conta anche il rownames)
digits=c(0,1,1,1) # inserire un valore in piu' rispetto al numero delle colonne (questo perche' xtable conta anche il rownames)
)
carb0100 <- xtable(
a3,
#caption=c('Tavola 1.10 BAM - CARB0100'),
#label=c('tab:a10.a'),
align = c("l", "l", rep("S[table-format=-2]", 2)), # inserire un valore in piu' rispetto al numero delle colonne (questo perche' xtable conta anche il rownames)
digits=c(0,1,1,1) # inserire un valore in piu' rispetto al numero delle colonne (questo perche' xtable conta anche il rownames)
)
align
align = c("l", "l", rep("S[table-format=-2]", 2))
align
carb0100 <- xtable(
a3,
#caption=c('Tavola 1.10 BAM - CARB0100'),
#label=c('tab:a10.a'),
align = c("{@{}l", "l", rep("S[table-format=-2]", 2), '{@{}'), # inserire un valore in piu' rispetto al numero delle colonne (questo perche' xtable conta anche il rownames)
digits=c(0,1,1,1) # inserire un valore in piu' rispetto al numero delle colonne (questo perche' xtable conta anche il rownames)
)
carb0100 <- xtable(
a3,
#caption=c('Tavola 1.10 BAM - CARB0100'),
#label=c('tab:a10.a'),
align = c("{@{}l", "l", rep("S[table-format=-2]", 8), '"S[table-format=-2]"{@{}'), # inserire un valore in piu' rispetto al numero delle colonne (questo perche' xtable conta anche il rownames)
digits=c(0,1,1,1,1,1,1,1,1,1,1) # inserire un valore in piu' rispetto al numero delle colonne (questo perche' xtable conta anche il rownames)
)
carb0100 <- xtable(
a10,
#caption=c('Tavola 1.10 BAM - CARB0100'),
#label=c('tab:a10.a'),
align = c("{@{}l", "l", rep("S[table-format=-2]", 8), '"S[table-format=-2]"{@{}'), # inserire un valore in piu' rispetto al numero delle colonne (questo perche' xtable conta anche il rownames)
digits=c(0,1,1,1,1,1,1,1,1,1,1) # inserire un valore in piu' rispetto al numero delle colonne (questo perche' xtable conta anche il rownames)
)
carb0100 <- xtable(
a10,
#caption=c('Tavola 1.10 BAM - CARB0100'),
#label=c('tab:a10.a'),
align = c("{@{}l", "l", rep("S[table-format=-2]", 8), '"S[table-format=-2]"{@{}'), # inserire un valore in piu' rispetto al numero delle colonne (questo perche' xtable conta anche il rownames)
digits=c(0,1,1,1,1,1,1,1,1,1,1) # inserire un valore in piu' rispetto al numero delle colonne (questo perche' xtable conta anche il rownames)
)
addtorow$pos <- as.list(c(0, nrow(a10)))
addtorow$command <- c(
intestazione, # primo elemento di command, che va nella riga identificata dal primo elemento di pos (riga 0)
#rep('\\rowcolor{blu_row} ', length(seq(1, nrow(a10)-1, 2))),
'\\bottomrule'
)
# addtorow$pos <- list()
# addtorow$pos[[1]] <- 0
# #addtorow$pos[[2]] <- 0
# #addtorow$pos[[3]] <- 5
# addtorow$pos[[2]] <- nrow(d1)
# addtorow$pos[[3]] <- 3
addtorow$pos <- as.list(c(0, seq(1, nrow(a10)-1, 2), nrow(a10)))
addtorow$command <- c(
intestazione, # primo elemento di command, che va nella riga identificata dal primo elemento di pos (riga 0)
rep('\\rowcolor{blu_row} ', length(seq(1, nrow(a10)-1, 2))),
'\\bottomrule'
)
setwd("D:/Utenti/Francesco/Google Drive/r programs/shiny/due-sicilie")
shiny::runApp()
install.packages("viridis")
options(stringsAsFactors = F)
library(viridis)
# Apro lo shpaefile
shp <- readOGR('shp')
shp@data$id <- rownames(shp@data)
colnames(shp@data) <- tolower(colnames(shp@data))
# Apro il file excel e unisco i dati allo shapefile
ds <- as.data.frame(read_excel(path = 'comuni.xlsx'))
colnames(ds) <- tolower(colnames(ds))
shp <- merge(shp, ds)
# Elimino le geometrie che non fanno parte del dataset 'ds'
shp <- subset(shp, !(is.na(shp@data$ds_prog)))
# Converto shp in un dataframe contenente tutti i dati disaggregati per comune
comuni <- fortify(shp)
comuni <- merge(comuni, shp)
ui <- fluidPage(
sidebarLayout(
sidebarPanel(width = 3,
selectInput(
inputId = "distretto",
label = "Seleziona il distretto: ", choices = unique(ds$ds_distretto),
selected = ""
),
uiOutput('comune'),
plotOutput("uiMap")
),
mainPanel(width = 9,
plotOutput("map", width="1000px", height="600px"))
)
)
server <- (function(input, output) {
data <- reactive({
data <- comuni[comuni$ds_distretto %in% (input$distretto),]
})
output$comune <- renderUI({
selectInput(
inputId = "comune",
label = "Seleziona il comune: ", choices = c("", unique(data()[, "ds_den_mod"])),
selected = ""
)
})
# output$uiMap <- renderPlot({
#   ggplot() +
#     theme_void() +
#     coord_equal() +
#     geom_polygon(data = df$province, mapping = aes(x=long, y=lat, group=group), fill=NA, color='black', size=0.01) +
#     #geom_polygon(data = data(), mapping = aes(x=long, y=lat, group=group, fill=data()$ds_distretto), color='black', size=0.01) +
#     geom_polygon(data = df$distretti[df$distretti$ds_distretto %in% input$distretto,], mapping = aes(x=long, y=lat, group=group, fill=ds_distretto)) +
#     scale_fill_viridis(discrete = T) +
#     theme(legend.position = 'none')
# })
output$map <- renderPlot({
ggplot() +
theme_void() +
coord_equal() +
geom_polygon(data = data(), mapping = aes(x=long, y=lat, group=group, fill=ds_circondario), color='black', size=0.01) +
geom_polygon(data = data()[data()$ds_den_mod %in% input$comune,], mapping = aes(x=long, y=lat, group=group), color='red', size=1, fill=NA) +
scale_fill_viridis(discrete = T)
})
})
runApp()
View(ds)
runApp()
runApp()
runApp()
library(shiny)
library(maptools)
library(ggplot2)
library(rgdal)
library(broom)
library(raster)
library(readxl)
library(viridis)
library(reshape)
options(stringsAsFactors = F)
# Apro lo shpaefile
shp <- readOGR('shp')
shp@data$id <- rownames(shp@data)
colnames(shp@data) <- tolower(colnames(shp@data))
#shp2 <- shp
# Apro il file excel e unisco i dati allo shapefile
ds <- as.data.frame(read_excel(path = 'comuni.xlsx'))
colnames(ds) <- tolower(colnames(ds))
shp <- merge(shp, ds)
# Elimino le geometrie che non fanno parte del dataset 'ds'
shp <- subset(shp, !(is.na(shp@data$ds_prog)))
# Converto shp in un dataframe contenente tutti i dati disaggregati per comune
comuni <- fortify(shp)
comuni <- merge(comuni, shp)
# # Dissolvo shp per circondario, distretto e provincia
# # Creo una lista, 'lsp', che conterrà i Large Spatial Polygons e una lista, 'df', che conterrà i dataframe
# lsp <- list()
# df <- list()
#
# lsp$province <- raster::aggregate(shp, 'ds_provincia')
# lsp$province@data$id <- rownames(lsp$province@data)
# df$province <- fortify(lsp$province)
# df$province <- merge(df$province, lsp$province)
#
# lsp$distretti <- raster::aggregate(shp, 'ds_distretto')
# lsp$distretti@data$id <- rownames(lsp$distretti@data)
# df$distretti <- fortify(lsp$distretti)
# df$distretti <- merge(df$distretti, lsp$distretti)
ui <- fluidPage(
sidebarLayout(
sidebarPanel(width = 3,
selectInput(
inputId = "distretto",
label = "Seleziona il distretto: ", choices = unique(ds$ds_distretto),
selected = ""
)
# ),
# uiOutput('comune'),
# plotOutput("uiMap")
),
mainPanel(width = 9,
plotOutput("map", width="1000px", height="600px"))
)
)
server <- (function(input, output) {
data <- reactive({
data <- comuni[comuni$ds_distretto %in% (input$distretto),]
})
# output$comune <- renderUI({
#   selectInput(
#     inputId = "comune",
#     label = "Seleziona il comune: ", choices = c("", unique(data()[, "ds_den_mod"])),
#     selected = ""
#   )
#})
# output$uiMap <- renderPlot({
#   ggplot() +
#     theme_void() +
#     coord_equal() +
#     geom_polygon(data = df$province, mapping = aes(x=long, y=lat, group=group), fill=NA, color='black', size=0.01) +
#     #geom_polygon(data = data(), mapping = aes(x=long, y=lat, group=group, fill=data()$ds_distretto), color='black', size=0.01) +
#     geom_polygon(data = df$distretti[df$distretti$ds_distretto %in% input$distretto,], mapping = aes(x=long, y=lat, group=group, fill=ds_distretto)) +
#     scale_fill_viridis(discrete = T) +
#     theme(legend.position = 'none')
# })
output$map <- renderPlot({
ggplot() +
theme_void() +
coord_equal() +
geom_polygon(data = data(), mapping = aes(x=long, y=lat, group=group, fill=ds_circondario), color='black', size=0.01) +
geom_polygon(data = data()[data()$ds_den_mod %in% input$comune,], mapping = aes(x=long, y=lat, group=group), color='red', size=1, fill=NA) +
scale_fill_viridis(discrete = T)
})
})
shinyApp(ui = ui, server = server)
runApp()
runApp()
library(shiny)
library(maptools)
library(ggplot2)
library(rgdal)
library(broom)
library(raster)
library(readxl)
library(viridis)
library(reshape)
options(stringsAsFactors = F)
# Apro lo shpaefile
shp <- readOGR('shp')
shp@data$id <- rownames(shp@data)
colnames(shp@data) <- tolower(colnames(shp@data))
#shp2 <- shp
# Apro il file excel e unisco i dati allo shapefile
ds <- as.data.frame(read_excel(path = 'comuni.xlsx'))
colnames(ds) <- tolower(colnames(ds))
shp <- merge(shp, ds)
# Elimino le geometrie che non fanno parte del dataset 'ds'
shp <- subset(shp, !(is.na(shp@data$ds_prog)))
# Converto shp in un dataframe contenente tutti i dati disaggregati per comune
comuni <- fortify(shp)
comuni <- merge(comuni, shp)
# # Dissolvo shp per circondario, distretto e provincia
# # Creo una lista, 'lsp', che conterrà i Large Spatial Polygons e una lista, 'df', che conterrà i dataframe
# lsp <- list()
# df <- list()
#
# lsp$province <- raster::aggregate(shp, 'ds_provincia')
# lsp$province@data$id <- rownames(lsp$province@data)
# df$province <- fortify(lsp$province)
# df$province <- merge(df$province, lsp$province)
#
# lsp$distretti <- raster::aggregate(shp, 'ds_distretto')
# lsp$distretti@data$id <- rownames(lsp$distretti@data)
# df$distretti <- fortify(lsp$distretti)
# df$distretti <- merge(df$distretti, lsp$distretti)
ui <- fluidPage(
sidebarLayout(
sidebarPanel(width = 3,
selectInput(
inputId = "distretto",
label = "Seleziona il distretto: ", choices = unique(ds$ds_distretto),
selected = ""
)
# ),
# uiOutput('comune'),
# plotOutput("uiMap")
),
mainPanel(width = 9,
plotOutput("map", width="1000px", height="600px"))
)
)
server <- (function(input, output) {
data <- reactive({
data <- comuni[comuni$ds_distretto %in% (input$distretto),]
})
# output$comune <- renderUI({
#   selectInput(
#     inputId = "comune",
#     label = "Seleziona il comune: ", choices = c("", unique(data()[, "ds_den_mod"])),
#     selected = ""
#   )
#})
# output$uiMap <- renderPlot({
#   ggplot() +
#     theme_void() +
#     coord_equal() +
#     geom_polygon(data = df$province, mapping = aes(x=long, y=lat, group=group), fill=NA, color='black', size=0.01) +
#     #geom_polygon(data = data(), mapping = aes(x=long, y=lat, group=group, fill=data()$ds_distretto), color='black', size=0.01) +
#     geom_polygon(data = df$distretti[df$distretti$ds_distretto %in% input$distretto,], mapping = aes(x=long, y=lat, group=group, fill=ds_distretto)) +
#     scale_fill_viridis(discrete = T) +
#     theme(legend.position = 'none')
# })
output$map <- renderPlot({
ggplot() +
theme_void() +
coord_equal() +
geom_polygon(data = data(), mapping = aes(x=long, y=lat, group=group, fill=ds_circondario), color='black', size=0.01) +
geom_polygon(data = data()[data()$ds_den_mod %in% input$comune,], mapping = aes(x=long, y=lat, group=group), color='red', size=1, fill=NA) +
scale_fill_viridis(discrete = T)
})
})
shinyApp(ui = ui, server = server)
options(stringsAsFactors = F)
# Apro lo shpaefile
shp <- readOGR('shp')
shp@data$id <- rownames(shp@data)
colnames(shp@data) <- tolower(colnames(shp@data))
#shp2 <- shp
# Apro il file excel e unisco i dati allo shapefile
ds <- as.data.frame(read_excel(path = 'comuni.xlsx'))
colnames(ds) <- tolower(colnames(ds))
shp <- merge(shp, ds)
# Elimino le geometrie che non fanno parte del dataset 'ds'
shp <- subset(shp, !(is.na(shp@data$ds_prog)))
# Converto shp in un dataframe contenente tutti i dati disaggregati per comune
comuni <- fortify(shp)
comuni <- merge(comuni, shp)
# Dissolvo shp per circondario, distretto e provincia
# Creo una lista, 'lsp', che conterrà i Large Spatial Polygons e una lista, 'df', che conterrà i dataframe
lsp <- list()
df <- list()
lsp$province <- raster::aggregate(shp, 'ds_provincia')
lsp$province@data$id <- rownames(lsp$province@data)
df$province <- fortify(lsp$province)
df$province <- merge(df$province, lsp$province)
lsp$distretti <- raster::aggregate(shp, 'ds_distretto')
lsp$distretti@data$id <- rownames(lsp$distretti@data)
df$distretti <- fortify(lsp$distretti)
df$distretti <- merge(df$distretti, lsp$distretti)
ui <- fluidPage(
sidebarLayout(
sidebarPanel(width = 3,
selectInput(
inputId = "distretto",
label = "Seleziona il distretto: ", choices = unique(ds$ds_distretto),
selected = ""
),
uiOutput('comune'),
plotOutput("uiMap")
),
mainPanel(width = 9,
plotOutput("map", width="1000px", height="600px"))
)
)
server <- (function(input, output) {
data <- reactive({
data <- comuni[comuni$ds_distretto %in% (input$distretto),]
})
output$comune <- renderUI({
selectInput(
inputId = "comune",
label = "Seleziona il comune: ", choices = c("", unique(data()[, "ds_den_mod"])),
selected = ""
)
})
output$uiMap <- renderPlot({
ggplot() +
theme_void() +
coord_equal() +
geom_polygon(data = df$province, mapping = aes(x=long, y=lat, group=group), fill=NA, color='black', size=0.01) +
#geom_polygon(data = data(), mapping = aes(x=long, y=lat, group=group, fill=data()$ds_distretto), color='black', size=0.01) +
geom_polygon(data = df$distretti[df$distretti$ds_distretto %in% input$distretto,], mapping = aes(x=long, y=lat, group=group, fill=ds_distretto)) +
scale_fill_viridis(discrete = T) +
theme(legend.position = 'none')
})
output$map <- renderPlot({
ggplot() +
theme_void() +
coord_equal() +
geom_polygon(data = data(), mapping = aes(x=long, y=lat, group=group, fill=ds_circondario), color='black', size=0.01) +
geom_polygon(data = data()[data()$ds_den_mod %in% input$comune,], mapping = aes(x=long, y=lat, group=group), color='red', size=1, fill=NA) +
scale_fill_viridis(discrete = T)
})
})
shinyApp(ui = ui, server = server)
runApp()
runApp()
runApp()
runApp()
runApp()
options(stringsAsFactors = F)
# Apro lo shpaefile
shp <- readOGR('shp')
shp@data$id <- rownames(shp@data)
colnames(shp@data) <- tolower(colnames(shp@data))
#shp2 <- shp
# Apro il file excel e unisco i dati allo shapefile
ds <- as.data.frame(read_excel(path = 'comuni.xlsx'))
colnames(ds) <- tolower(colnames(ds))
shp <- merge(shp, ds)
# Elimino le geometrie che non fanno parte del dataset 'ds'
shp <- subset(shp, !(is.na(shp@data$ds_prog)))
# Converto shp in un dataframe contenente tutti i dati disaggregati per comune
comuni <- fortify(shp)
comuni <- merge(comuni, shp)
# Dissolvo shp per circondario, distretto e provincia
# Creo una lista, 'lsp', che conterrà i Large Spatial Polygons e una lista, 'df', che conterrà i dataframe
lsp <- list()
df <- list()
lsp$province <- raster::aggregate(shp, 'ds_provincia')
lsp$province@data$id <- rownames(lsp$province@data)
df$province <- fortify(lsp$province)
df$province <- merge(df$province, lsp$province)
lsp$distretti <- raster::aggregate(shp, 'ds_distretto')
lsp$distretti@data$id <- rownames(lsp$distretti@data)
df$distretti <- fortify(lsp$distretti)
df$distretti <- merge(df$distretti, lsp$distretti)
input <- list()
input$distretto <- 'Avellino'
ggplot() +
theme_void() +
coord_equal() +
geom_polygon(data = df$province, mapping = aes(x=long, y=lat, group=group), fill=NA, color='black', size=1) +
#geom_polygon(data = data(), mapping = aes(x=long, y=lat, group=group, fill=data()$ds_distretto), color='black', size=0.01) +
geom_polygon(data = df$distretti[df$distretti$ds_distretto %in% input$distretto,],
mapping = aes(x=long, y=lat, group=group, fill=ds_distretto)) +
scale_fill_viridis(discrete = T) +
theme(legend.position = 'none')
ggplot() +
theme_void() +
coord_equal() +
geom_polygon(data = df$province, mapping = aes(x=long, y=lat, group=group), fill=NA, color='black', size=0.1) +
#geom_polygon(data = data(), mapping = aes(x=long, y=lat, group=group, fill=data()$ds_distretto), color='black', size=0.01) +
geom_polygon(data = df$distretti[df$distretti$ds_distretto %in% input$distretto,],
mapping = aes(x=long, y=lat, group=group), fill='red') +
scale_fill_viridis(discrete = T) +
theme(legend.position = 'none')
runApp()
runApp()
View(ds)
runApp()
runApp()
runApp()
runApp()
runApp()
